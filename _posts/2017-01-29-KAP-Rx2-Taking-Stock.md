---
layout: post
title: "Taking stock of kap-rx2"
date: 2017-01-29
---

Some time ago (about a year?) I started a project, kap-rx2 that I
wanted to grow into a new KAP receiver.  It didn't get far before it
went dormant but lately I've been putting it back on the front burner.
At the moment, it runs FreeRTOS and an event manager with some degree
of buffer management.  It has a CLI that runs over a UART (USART2) and
there's an ESP8266 connected on USART6.

About the only thing the code actually does right now is act as a
terminal between the console and the ESP8266.  So one can manually
type AT commands and see how the ESP8266 responds.

Since I want to resume work on this, I feel I need to review the software pieces already in place.

## Software Architecture

The basic software architecture is based on FreeRTOS, which provides
threading, and an event processor, which provides lightweight
event-driven capabilities.

The application is written, primarily in C++.

### main

Main (as well as the project file) were generated by STM32CubeMX.

A lot of MX subsystems get initialized.

serial_init() is called to initialize the two serial interfaces.

defaultTask is created.  This task, in main.c, initializes FATFS, prints the "kap-rx2 controller" message, starts hardware PWM, then runs CLI.

evtMgrInit() is called to create event manager task.

### Tasks

defaultTask, in main.c, runs the CLI loop after system initialization.
etMgrTask, in EvtMgr.cpp, runs the event manager thread.

### Event Manager

The event manager is implemented as a FreeRTOS task.  So all events
are dispatched in the context of this one thread.

EvtMgr class:
* issueEvent adds an event (with EventType and opaque data), to queue.
* issueEventIsr does the same in ISR context.
* registerHandler registers a handler to receive events of a particular type.
* registerFinalizer does the same for finalizers.

[ ] Why is EvtMgr an EventHandler and EventFinalizer?
[ ] Why are separate EventHandler, EventFinalizer methods needed?

At present, it appears that the event manager is basically unused.
The only the event manager itself registers for or issues any events.
The implemented events include EVT_INIT, EVT_10MS, EVT_1S.  

Buffer manager isn't referenced in EvtMgr.

### Buffer Manager

A buffer manager exists to support simple alloc/dealloc with reference
counts of buffers.  Memory allocation is based on a set of fixed size
buffers that can be strung together, if necessary to store larger data
sets.  So the stored data is not continguous in memory.  Currently 32
buffers of 64 bytes are managed.

Methods exist to read out a buffer chain as a continuous string,
append data to a buffer and add and remove references.

API seems a bit odd.  Buffers are allocated through BufMgr::alloc but
freed by using Buffer::rmRef.  (Would be better to add an alloc method
to Buffer.)

Currently it seems there are no users of the Buffer Manager.  Indeed,
the Buffer Manager is not linked in to the current application.

### Serial Driver

Supports getPort(), read(buf, len) and write(buf, len) on USART devices.

serial_init called by main to initialize ports.
port id 0 is set as console port.  (Becomes basis of stdio, printf calls)

### CLI

There is a basic CLI.  It uses stdio, (fgetc, printf, fflush), for
input and output.  It runs as a task when the default task calls
cli_run().

A help command is built in to the command interpreter.
A conStats command is supplied by the serial driver.
ioTest command performs 1000 writes to the serial port.
esp command runs an interactive terminal with ESP8266 until ^C is keyed.

### Button

Button.c implements button polling.

### Debug support

The debug module has functions to set, clear, pulse the debug GPIO
signal.  Generally, this is for observation with a logic analyzer.

### Timers (BLDC and Servo controls)
(Unimplemented)

### SD, FAT Filesystem
(Unimplemented)

----------------------------------------------------------------
## Hardware Resources

TIM1    : CH1 - Servo PWM., CH3 input capture?
TIM2    : CH1 - CH3 for BLDC drive
TIM3    : CH1 - CH4 for BLDC drive
TIM4    : CH3, CH4 - Input capture (BNO intn timing?)
TIM5    : CH1, CH2 - BLDC drive
TIM9    : Timebase source.
TIM11   : Not enabled.
USART2  : CLI
USART6  : ESP8266 connection
I2C1    : BNO080 (I2C option)
  PC0   : BNO_INTN
  PC1   : BNO_RSTN
  PC2   : BNO_BOOTN
  PC3   : BNO_PS1
  PC13  : BNO_INTN2 (User button)
  
SDIO_SD : uSD interface
SPI1    : BLDC Driver (old).
  PA4   : BLDC_EN
  PC4   : BLDC_CS0
  PC5   : BLDC_CS1
USB     : USB interface.

PC12    : Debug
PA5     : Nucleo LED (is SPI SCLK)

Unallocated:
PB2
PB12
PB13
PB14
PC14
PC15


### BNO080 Connection (planned)

----------------------------------------------------------------
## Changes, Enhancements needed.

[x] In button module, poll button via 10ms event and generate button
    events.
* Add LED module.
[x] Abstract Serial public interface.
* Integrate buffer management with event processing.
  (Associate buffer with event at issue, rmRef at end of dispatch
  cycle.)
* Create WiFi process to manage comms with ESP8266.
* Create WiFi Mgr controlled by events.
* Create BNO080 module.



